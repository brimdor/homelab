package test

import (
	"errors"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

func TestClawdbotParseTimeWithZone_DefaultsToSystemTZ(t *testing.T) {
	t.Parallel()

	valuesPath := filepath.Join("..", "apps", "clawdbot", "values.yaml")
	bytes, err := os.ReadFile(valuesPath)
	if err != nil {
		t.Fatalf("read %s: %v", valuesPath, err)
	}

	parseJS, err := extractYamlLiteralBlock(string(bytes), "parse.js: |", "schedule.js: |")
	if err != nil {
		t.Fatalf("extract parse.js block: %v", err)
	}

	// Convert the patched module into a runnable script.
	parseJS = strings.ReplaceAll(parseJS, "export ", "")

	script := strings.Join([]string{
		"// Generated by test/clawdbot_cron_time_test.go",
		"const assertEq = (got, want, label) => {",
		"  if (got !== want) {",
		"    console.error(label + ': expected=' + want + ' got=' + got);",
		"    process.exit(1);",
		"  }",
		"};",
		parseJS,
		"const expectedLocal0900 = Date.parse('2026-01-27T09:00:00-06:00');",
		"assertEq(parseTimeWithZone('2026-01-27 09:00', undefined), expectedLocal0900, 'default tz (system)');",
		"assertEq(parseTimeWithZone('2026-01-27 09:00', 'America/Chicago'), expectedLocal0900, 'explicit tz');",
		"assertEq(parseTimeWithZone('2026-01-27T09:00:00Z', undefined), Date.parse('2026-01-27T09:00:00Z'), 'explicit Z');",
		"const expectedMidnight = Date.parse('2026-01-27T00:30:00-06:00');",
		"assertEq(parseTimeWithZone('2026-01-27 00:30', undefined), expectedMidnight, 'near midnight');",
		"// Mirrors an agent computing now+10m as a local wall-clock string (no tz provided).",
		"const expectedIn10 = Date.parse('2026-01-27T12:10:00-06:00');",
		"assertEq(parseTimeWithZone('2026-01-27 12:10', undefined), expectedIn10, 'relative via local string');",
		"console.log('ok');",
	}, "\n")

	tmpDir := t.TempDir()
	scriptPath := filepath.Join(tmpDir, "parse_time_test.js")
	if err := os.WriteFile(scriptPath, []byte(script), 0o600); err != nil {
		t.Fatalf("write script: %v", err)
	}

	output, err := runNodeScript(scriptPath)
	if err != nil {
		t.Fatalf("run node script: %v\n%s", err, output)
	}
	if strings.TrimSpace(output) != "ok" {
		t.Fatalf("unexpected output: %q", output)
	}
}

func runNodeScript(scriptPath string) (string, error) {
	if nodePath, err := exec.LookPath("node"); err == nil {
		cmd := exec.Command(nodePath, scriptPath)
		cmd.Env = append(os.Environ(), "TZ=America/Chicago")
		out, runErr := cmd.CombinedOutput()
		return string(out), runErr
	}

	// Fallback: try running via podman if node isn't installed.
	podmanPath, err := exec.LookPath("podman")
	if err != nil {
		return "", errors.New("neither node nor podman found in PATH")
	}
	cmd := exec.Command(
		podmanPath,
		"run", "--rm",
		"-e", "TZ=America/Chicago",
		"-v", scriptPath+":/test.js:ro",
		"docker.io/library/node:20",
		"node", "/test.js",
	)
	out, runErr := cmd.CombinedOutput()
	return string(out), runErr
}

func extractYamlLiteralBlock(contents, startMarker, endMarker string) (string, error) {
	start := strings.Index(contents, startMarker)
	if start == -1 {
		return "", errors.New("start marker not found")
	}

	// Start after the marker line.
	start = strings.Index(contents[start:], "\n") + start + 1
	if start <= 0 || start >= len(contents) {
		return "", errors.New("invalid start marker")
	}

	end := strings.Index(contents[start:], endMarker)
	if end == -1 {
		return "", errors.New("end marker not found")
	}
	end += start

	block := contents[start:end]
	lines := strings.Split(block, "\n")
	minIndent := -1
	for _, line := range lines {
		if strings.TrimSpace(line) == "" {
			continue
		}
		indent := len(line) - len(strings.TrimLeft(line, " "))
		if minIndent == -1 || indent < minIndent {
			minIndent = indent
		}
	}
	if minIndent > 0 {
		for i, line := range lines {
			if len(line) >= minIndent {
				lines[i] = strings.TrimPrefix(line, strings.Repeat(" ", minIndent))
			}
		}
	}

	return strings.TrimSpace(strings.Join(lines, "\n")) + "\n", nil
}
