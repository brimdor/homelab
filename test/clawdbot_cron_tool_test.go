package test

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestClawdbotCronTool_CoerceAtScheduleGuards(t *testing.T) {
	t.Parallel()

	valuesPath := filepath.Join("..", "apps", "clawdbot", "values.yaml")
	bytes, err := os.ReadFile(valuesPath)
	if err != nil {
		t.Fatalf("read %s: %v", valuesPath, err)
	}

	cronToolJS, err := extractYamlLiteralBlock(string(bytes), "cron-tool.js: |", "schedule.js: |")
	if err != nil {
		t.Fatalf("extract cron-tool.js block: %v", err)
	}

	start := strings.Index(cronToolJS, "const RELATIVE_MIN_DELAY_MS")
	end := strings.Index(cronToolJS, "const CronToolSchema")
	if start == -1 || end == -1 || end <= start {
		t.Fatalf("unable to locate helper snippet in cron-tool.js")
	}
	snippet := cronToolJS[start:end]

	script := strings.Join([]string{
		"// Generated by test/clawdbot_cron_tool_test.go",
		"const assert = (cond, label) => { if (!cond) { console.error('assert failed: ' + label); process.exit(1); } };",
		snippet,
		"// 1) atMs-only should be rejected",
		"let threw = false;",
		"try { coerceAtSchedule({ kind: 'at', atMs: 123 }); } catch { threw = true; }",
		"assert(threw, 'reject atMs-only');",
		"// 2) at string should delete atMs",
		"const s2 = coerceAtSchedule({ kind: 'at', at: '2026-01-27 16:50', atMs: 999 });",
		"assert(s2.kind === 'at', 'keep kind at');",
		"assert(typeof s2.at === 'string' && s2.at.length > 0, 'keep at');",
		"assert(!('atMs' in s2), 'atMs removed when at present');",
		"// 3) afterMinutes should translate to kind=at with formatted at string",
		"const s3 = coerceAtSchedule({ afterMinutes: 2 });",
		"assert(s3.kind === 'at', 'afterMinutes -> kind at');",
		"assert(typeof s3.at === 'string' && s3.at.length > 0, 'afterMinutes -> at string');",
		"assert(!('atMs' in s3), 'afterMinutes does not use atMs');",
		"console.log('ok');",
	}, "\n")

	output, runErr := runNodeInline(script)
	if runErr != nil {
		t.Fatalf("run node: %v\n%s", runErr, output)
	}
	if strings.TrimSpace(output) != "ok" {
		t.Fatalf("unexpected output: %q", output)
	}
}

func runNodeInline(script string) (string, error) {
	f, err := os.CreateTemp("", "clawdbot_cron_tool_*.js")
	if err != nil {
		return "", err
	}
	defer os.Remove(f.Name())
	if _, err := f.WriteString(script); err != nil {
		_ = f.Close()
		return "", err
	}
	if err := f.Close(); err != nil {
		return "", err
	}
	return runNodeScript(f.Name())
}
