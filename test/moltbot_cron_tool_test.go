package test

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestMoltbotCronTool_CoerceAtScheduleGuards(t *testing.T) {
	t.Parallel()

	valuesPath := filepath.Join("..", "apps", "moltbot", "values.yaml")
	bytes, err := os.ReadFile(valuesPath)
	if err != nil {
		t.Fatalf("read %s: %v", valuesPath, err)
	}

	cronToolJS, err := extractYamlLiteralBlock(string(bytes), "cron-tool.js: |", "schedule.js: |")
	if err != nil {
		t.Fatalf("extract cron-tool.js block: %v", err)
	}

	start := strings.Index(cronToolJS, "const RELATIVE_MIN_DELAY_MS")
	end := strings.Index(cronToolJS, "const CronToolSchema")
	if start == -1 || end == -1 || end <= start {
		t.Fatalf("unable to locate helper snippet in cron-tool.js")
	}
	snippet := cronToolJS[start:end]
	wrapped := strings.Join([]string{
		"(function(){",
		snippet,
		"globalThis.coerceAtSchedule = coerceAtSchedule;",
		"})();",
	}, "\n")

	parseJS, err := extractYamlLiteralBlock(string(bytes), "parse.js: |", "schedule.js: |")
	if err != nil {
		t.Fatalf("extract parse.js block: %v", err)
	}
	parseJS = strings.ReplaceAll(parseJS, "export ", "")

	script := strings.Join([]string{
		"// Generated by test/moltbot_cron_tool_test.go",
		"const assert = (cond, label) => { if (!cond) { console.error('assert failed: ' + label); process.exit(1); } };",
		parseJS,
		wrapped,
		"// 1) atMs-only should pass through as gateway schema",
		"const s1 = coerceAtSchedule({ kind: 'at', atMs: 123 });",
		"assert(s1.kind === 'at' && s1.atMs === 123, 'atMs passthrough');",
		"assert(!('at' in s1) && !('tz' in s1), 'no at/tz on output');",
		"// 2) at string should convert to atMs",
		"const s2 = coerceAtSchedule({ kind: 'at', at: '2026-01-27 16:50', tz: 'America/Chicago' });",
		"assert(s2.kind === 'at', 'at string -> kind at');",
		"assert(typeof s2.atMs === 'number' && Number.isFinite(s2.atMs), 'at string -> atMs');",
		"assert(!('at' in s2) && !('tz' in s2), 'no at/tz on output');",
		"// 3) afterMinutes should translate to kind=at with atMs",
		"const before = Date.now();",
		"const s3 = coerceAtSchedule({ afterMinutes: 2 });",
		"const after = Date.now();",
		"assert(s3.kind === 'at', 'afterMinutes -> kind at');",
		"assert(typeof s3.atMs === 'number' && Number.isFinite(s3.atMs), 'afterMinutes -> atMs');",
		"assert(s3.atMs >= before + 2*60*1000 - 2000 && s3.atMs <= after + 2*60*1000 + 2000, 'afterMinutes ~ now+2m');",
		"// 4) payload-derived timer minutes should override drift",
		"const b4 = Date.now();",
		"const s4 = coerceAtSchedule({ kind: 'at', atMs: 1 }, 'Your 2-minute timer has ended!');",
		"const a4 = Date.now();",
		"assert(s4.kind === 'at' && typeof s4.atMs === 'number', 'payload timer -> atMs');",
		"assert(s4.atMs >= b4 + 2*60*1000 - 2000 && s4.atMs <= a4 + 2*60*1000 + 2000, 'payload timer ~ now+2m');",
		"console.log('ok');",
	}, "\n")

	output, runErr := runNodeInline(script)
	if runErr != nil {
		t.Fatalf("run node: %v\n%s", runErr, output)
	}
	if strings.TrimSpace(output) != "ok" {
		t.Fatalf("unexpected output: %q", output)
	}
}

func runNodeInline(script string) (string, error) {
	f, err := os.CreateTemp("", "moltbot_cron_tool_*.js")
	if err != nil {
		return "", err
	}
	defer os.Remove(f.Name())
	if _, err := f.WriteString(script); err != nil {
		_ = f.Close()
		return "", err
	}
	if err := f.Close(); err != nil {
		return "", err
	}
	return runNodeScript(f.Name())
}
