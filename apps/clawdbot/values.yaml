app-template:
  controllers:
    main:
      annotations:
        reloader.stakater.com/auto: "true"
      initContainers:
        fix-permissions:
          image:
            repository: docker.io/library/busybox
            tag: "1.36.1"
            pullPolicy: IfNotPresent
          command:
            - sh
            - -lc
            - |
              chown -R 1000:1000 /home/node/.clawdbot /home/node/clawd || true
          securityContext:
            runAsUser: 0

        tools-installer:
          image:
            repository: docker.io/library/debian
            tag: "12-slim"
            pullPolicy: IfNotPresent
          command:
            - sh
            - -lc
            - |
              set -eu
              export DEBIAN_FRONTEND=noninteractive

              apt-get update -y >/dev/null
              apt-get install -y --no-install-recommends ca-certificates curl unzip tar gzip >/dev/null
              update-ca-certificates >/dev/null 2>&1 || true

              mkdir -p /tools/bin /tmp/tools

              arch="$(dpkg --print-architecture)"
              case "$arch" in
                amd64)
                  OP_URL="https://cache.agilebits.com/dist/1P/op2/pkg/v2.27.0/op_linux_amd64_v2.27.0.zip"
                  GH_URL="https://github.com/cli/cli/releases/download/v2.53.0/gh_2.53.0_linux_amd64.tar.gz"
                  JQ_URL="https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-linux-amd64"
                  RG_URL="https://github.com/BurntSushi/ripgrep/releases/download/14.1.0/ripgrep-14.1.0-x86_64-unknown-linux-musl.tar.gz"
                  ;;
                arm64)
                  OP_URL="https://cache.agilebits.com/dist/1P/op2/pkg/v2.27.0/op_linux_arm64_v2.27.0.zip"
                  GH_URL="https://github.com/cli/cli/releases/download/v2.53.0/gh_2.53.0_linux_arm64.tar.gz"
                  JQ_URL="https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-linux-arm64"
                  RG_URL="https://github.com/BurntSushi/ripgrep/releases/download/14.1.0/ripgrep-14.1.0-aarch64-unknown-linux-musl.tar.gz"
                  ;;
                *)
                  echo "unsupported arch: $arch" >&2
                  exit 1
                  ;;
              esac

              # 1Password CLI (op)
              curl -fsSL "$OP_URL" -o /tmp/tools/op.zip
              unzip -q /tmp/tools/op.zip -d /tmp/tools/op
              install -m 0755 /tmp/tools/op/op /tools/bin/op

              # GitHub CLI (gh)
              curl -fsSL "$GH_URL" -o /tmp/tools/gh.tgz
              tar -xzf /tmp/tools/gh.tgz -C /tmp/tools
              install -m 0755 /tmp/tools/gh_*/bin/gh /tools/bin/gh

              # jq
              curl -fsSL "$JQ_URL" -o /tools/bin/jq
              chmod 0755 /tools/bin/jq

              # ripgrep (rg)
              curl -fsSL "$RG_URL" -o /tmp/tools/rg.tgz
              tar -xzf /tmp/tools/rg.tgz -C /tmp/tools
              install -m 0755 /tmp/tools/ripgrep-*/rg /tools/bin/rg

              # Clean up
              rm -rf /tmp/tools
          securityContext:
            runAsUser: 0
          volumeMounts:
            - name: tools
              mountPath: /tools
      containers:
        main:
          image:
            repository: 10.0.20.11:32309/clawdbot
            tag: latest
            pullPolicy: Always
          command: ["sh", "-lc", "sh /bootstrap/bootstrap.sh"]
          env:
            - name: TZ
              value: America/Chicago
            - name: PATH
              value: /tools/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
            - name: DISCORD_TOKEN
              valueFrom:
                secretKeyRef:
                  name: clawdbot-secret
                  key: discord-token
            - name: CLAWDBOT_GATEWAY_TOKEN
              valueFrom:
                secretKeyRef:
                  name: clawdbot-secret
                  key: gateway-token
            - name: CLAWDBOT_GATEWAY_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: clawdbot-secret
                  key: gateway-password

        ollama-proxy:
          image:
            repository: docker.io/library/alpine
            tag: "3.20"
            pullPolicy: IfNotPresent
          securityContext:
            runAsUser: 0
          command:
            - sh
            - -lc
            - |
              apk add --no-cache socat >/dev/null
              exec socat -d -d TCP-LISTEN:11434,bind=127.0.0.1,fork,reuseaddr TCP:ollama.ollama.svc.cluster.local:11434

  defaultPodOptions:
    securityContext:
      runAsUser: 1000
      runAsGroup: 1000
      fsGroup: 1000
      fsGroupChangePolicy: OnRootMismatch
    annotations:
      operator.1password.io/item-path: "vaults/4uaua4a45yuhnwhehp5bwylmti/items/2d2xphod42xwz2eoxs3tyyx7je"
      operator.1password.io/item-name: "clawdbot-secret"

  service:
    main:
      controller: main
      ports:
        http:
          port: 18789

  ingress:
    main:
      className: nginx
      annotations:
        cert-manager.io/cluster-issuer: "letsencrypt-prod"
      hosts:
        - host: &host clawdbot.eaglepass.io
          paths:
            - path: /
              pathType: Prefix
              service:
                identifier: main
                port: http
      tls:
        - hosts:
            - *host
          secretName: clawdbot-tls-certificate
        
  persistence:
    config:
      enabled: true
      type: persistentVolumeClaim
      accessMode: ReadWriteOnce
      size: 1Gi
      globalMounts:
        - path: /home/node/.clawdbot
    data:
      enabled: true
      type: persistentVolumeClaim
      accessMode: ReadWriteOnce
      size: 5Gi
      globalMounts:
        - path: /home/node/clawd

    tools:
      enabled: true
      type: emptyDir
      globalMounts:
        - path: /tools

    bootstrap:
      enabled: true
      type: configMap
      name: clawdbot-bootstrap
      defaultMode: 0755
      items:
        - key: bootstrap.sh
          path: bootstrap.sh
        - key: clawdbot
          path: clawdbot
      advancedMounts:
        main:
          main:
            - path: /bootstrap/bootstrap.sh
              subPath: bootstrap.sh
            - path: /usr/local/bin/clawdbot
              subPath: clawdbot

    patches:
      enabled: true
      type: configMap
      name: clawdbot-patches
      items:
        - key: auth.js
          path: auth.js
      advancedMounts:
        main:
          main:
            - path: /app/dist/gateway/auth.js
              subPath: auth.js

  configMaps:
    bootstrap:
      enabled: true
      forceRename: clawdbot-bootstrap
      data:
        clawdbot: |
          #!/bin/sh
          set -eu
          exec node /app/dist/index.js "$@"
        bootstrap.sh: |
          #!/bin/sh
          set -eu

          STATE_DIR="${CLAWDBOT_STATE_DIR:-/home/node/.clawdbot}"
          WORKSPACE_DIR="${CLAWDBOT_WORKSPACE_DIR:-/home/node/clawd}"

          mkdir -p "$STATE_DIR" "$WORKSPACE_DIR" \
            "$STATE_DIR/cron" "$WORKSPACE_DIR/canvas"

          # Doctor: keep state directory private and ensure OAuth dir exists.
          chmod 700 "$STATE_DIR" || true
          mkdir -p "$STATE_DIR/credentials"
          chmod 700 "$STATE_DIR/credentials" || true

          # Initialize config/workspace if missing.
          if [ ! -f "$STATE_DIR/clawdbot.json" ]; then
            node dist/index.js onboard \
              --non-interactive \
              --accept-risk \
              --flow manual \
              --mode local \
              --auth-choice skip \
              --workspace "$WORKSPACE_DIR" \
              --gateway-port 18789 \
              --gateway-bind lan \
              --gateway-auth password \
              --gateway-password "${CLAWDBOT_GATEWAY_PASSWORD:?missing}" \
              --skip-daemon \
              --skip-ui \
              --skip-health \
              --skip-channels \
              --skip-skills
          fi

          # Ensure auth profile store exists and enables Ollama provider discovery.
          # Note: Clawdbot's default agentDir is "$STATE_DIR/agents/main/agent".
          AUTH_DIR_OLD="$STATE_DIR/agents/main"
          AUTH_DIR="$STATE_DIR/agents/main/agent"
          AUTH_STORE_OLD="$AUTH_DIR_OLD/auth-profiles.json"
          AUTH_STORE="$AUTH_DIR/auth-profiles.json"

          if [ ! -f "$AUTH_STORE" ] && [ -f "$AUTH_STORE_OLD" ]; then
            mkdir -p "$AUTH_DIR"
            cp "$AUTH_STORE_OLD" "$AUTH_STORE"
          fi

          if [ ! -f "$AUTH_STORE" ]; then
            mkdir -p "$AUTH_DIR"
            cat > "$AUTH_STORE" <<'JSON'
          {
            "version": 1,
            "profiles": {
              "ollama:default": {
                "type": "api_key",
                "provider": "ollama",
                "key": "local"
              }
            },
            "order": {
              "ollama": ["ollama:default"]
            }
          }
          JSON
          fi

          # Enforce desired settings every start.
          node dist/index.js config set gateway.mode local
          node dist/index.js config set gateway.bind lan
          node dist/index.js config set gateway.auth.mode password
          node dist/index.js config unset gateway.auth.token || true
          # Control UI: allow password auth without device pairing.
          node dist/index.js config set gateway.controlUi.allowInsecureAuth true
          node dist/index.js config set gateway.controlUi.dangerouslyDisableDeviceAuth true
          node dist/index.js config set --json gateway.port 18789

          # Default agent model: Ollama Echo (served by cluster Ollama via localhost proxy).
          node dist/index.js config set agents.defaults.model.primary "ollama/Echo:latest"

          exec node dist/index.js gateway \
            --port 18789 \
            --bind lan \
            --auth password \
            --password "${CLAWDBOT_GATEWAY_PASSWORD:?missing}"

    patches:
      enabled: true
      forceRename: clawdbot-patches
      data:
        auth.js: |
          import { timingSafeEqual } from "node:crypto";
          import { readTailscaleWhoisIdentity } from "../infra/tailscale.js";
          import { isTrustedProxyAddress, parseForwardedForClientIp, resolveGatewayClientIp } from "./net.js";
          function safeEqual(a, b) {
              if (a.length !== b.length)
                  return false;
              return timingSafeEqual(Buffer.from(a), Buffer.from(b));
          }
          function normalizeLogin(login) {
              return login.trim().toLowerCase();
          }
          function isLoopbackAddress(ip) {
              if (!ip)
                  return false;
              if (ip === "127.0.0.1")
                  return true;
              if (ip.startsWith("127."))
                  return true;
              if (ip === "::1")
                  return true;
              if (ip.startsWith("::ffff:127."))
                  return true;
              return false;
          }
          function getHostName(hostHeader) {
              const host = (hostHeader ?? "").trim().toLowerCase();
              if (!host)
                  return "";
              if (host.startsWith("[")) {
                  const end = host.indexOf("]");
                  if (end !== -1)
                      return host.slice(1, end);
              }
              const [name] = host.split(":");
              return name ?? "";
          }
          function headerValue(value) {
              return Array.isArray(value) ? value[0] : value;
          }
          function resolveTailscaleClientIp(req) {
              if (!req)
                  return undefined;
              const forwardedFor = headerValue(req.headers?.["x-forwarded-for"]);
              return forwardedFor ? parseForwardedForClientIp(forwardedFor) : undefined;
          }
          function resolveRequestClientIp(req, trustedProxies) {
              if (!req)
                  return undefined;
              return resolveGatewayClientIp({
                  remoteAddr: req.socket?.remoteAddress ?? "",
                  forwardedFor: headerValue(req.headers?.["x-forwarded-for"]),
                  realIp: headerValue(req.headers?.["x-real-ip"]),
                  trustedProxies,
              });
          }
          export function isLocalDirectRequest(req, trustedProxies) {
              if (!req)
                  return false;
              const clientIp = resolveRequestClientIp(req, trustedProxies) ?? "";
              if (!isLoopbackAddress(clientIp))
                  return false;
              const host = getHostName(req.headers?.host);
              const hostIsLocal = host === "localhost" || host === "127.0.0.1" || host === "::1";
              const hostIsTailscaleServe = host.endsWith(".ts.net");
              const hasForwarded = Boolean(req.headers?.["x-forwarded-for"] ||
                  req.headers?.["x-real-ip"] ||
                  req.headers?.["x-forwarded-host"]);
              const remoteIsTrustedProxy = isTrustedProxyAddress(req.socket?.remoteAddress, trustedProxies);
              return (hostIsLocal || hostIsTailscaleServe) && (!hasForwarded || remoteIsTrustedProxy);
          }
          function getTailscaleUser(req) {
              if (!req)
                  return null;
              const login = req.headers["tailscale-user-login"];
              if (typeof login !== "string" || !login.trim())
                  return null;
              const nameRaw = req.headers["tailscale-user-name"];
              const profilePic = req.headers["tailscale-user-profile-pic"];
              const name = typeof nameRaw === "string" && nameRaw.trim() ? nameRaw.trim() : login.trim();
              return {
                  login: login.trim(),
                  name,
                  profilePic: typeof profilePic === "string" && profilePic.trim() ? profilePic.trim() : undefined,
              };
          }
          function hasTailscaleProxyHeaders(req) {
              if (!req)
                  return false;
              return Boolean(req.headers["x-forwarded-for"] &&
                  req.headers["x-forwarded-proto"] &&
                  req.headers["x-forwarded-host"]);
          }
          function isTailscaleProxyRequest(req) {
              if (!req)
                  return false;
              return isLoopbackAddress(req.socket?.remoteAddress) && hasTailscaleProxyHeaders(req);
          }
          async function resolveVerifiedTailscaleUser(params) {
              const { req, tailscaleWhois } = params;
              const tailscaleUser = getTailscaleUser(req);
              if (!tailscaleUser) {
                  return { ok: false, reason: "tailscale_user_missing" };
              }
              if (!isTailscaleProxyRequest(req)) {
                  return { ok: false, reason: "tailscale_proxy_missing" };
              }
              const clientIp = resolveTailscaleClientIp(req);
              if (!clientIp) {
                  return { ok: false, reason: "tailscale_whois_failed" };
              }
              const whois = await tailscaleWhois(clientIp);
              if (!whois?.login) {
                  return { ok: false, reason: "tailscale_whois_failed" };
              }
              if (normalizeLogin(whois.login) !== normalizeLogin(tailscaleUser.login)) {
                  return { ok: false, reason: "tailscale_user_mismatch" };
              }
              return {
                  ok: true,
                  user: {
                      login: whois.login,
                      name: whois.name ?? tailscaleUser.name,
                      profilePic: tailscaleUser.profilePic,
                  },
              };
          }
          export function resolveGatewayAuth(params) {
              const authConfig = params.authConfig ?? {};
              const env = params.env ?? process.env;
              const token = authConfig.token ?? env.CLAWDBOT_GATEWAY_TOKEN ?? undefined;
              const password = authConfig.password ?? env.CLAWDBOT_GATEWAY_PASSWORD ?? undefined;
              const mode = authConfig.mode ?? (password ? "password" : "token");
              const allowTailscale = authConfig.allowTailscale ?? (params.tailscaleMode === "serve" && mode !== "password");
              return {
                  mode,
                  token,
                  password,
                  allowTailscale,
              };
          }
          export function assertGatewayAuthConfigured(auth) {
              if (auth.mode === "token" && !auth.token) {
                  if (auth.allowTailscale)
                      return;
                  throw new Error("gateway auth mode is token, but no token was configured (set gateway.auth.token or CLAWDBOT_GATEWAY_TOKEN)");
              }
              if (auth.mode === "password" && !auth.password) {
                  throw new Error("gateway auth mode is password, but no password was configured");
              }
          }
          export async function authorizeGatewayConnect(params) {
              const { auth, connectAuth, req, trustedProxies } = params;
              const tailscaleWhois = params.tailscaleWhois ?? readTailscaleWhoisIdentity;
              const localDirect = isLocalDirectRequest(req, trustedProxies);
              if (auth.allowTailscale && !localDirect) {
                  const tailscaleCheck = await resolveVerifiedTailscaleUser({
                      req,
                      tailscaleWhois,
                  });
                  if (tailscaleCheck.ok) {
                      return {
                          ok: true,
                          method: "tailscale",
                          user: tailscaleCheck.user.login,
                      };
                  }
              }
              if (auth.mode === "token") {
                  if (!auth.token) {
                      return { ok: false, reason: "token_missing_config" };
                  }
                  if (!connectAuth?.token) {
                      return { ok: false, reason: "token_missing" };
                  }
                  if (!safeEqual(connectAuth.token, auth.token)) {
                      return { ok: false, reason: "token_mismatch" };
                  }
                  return { ok: true, method: "token" };
              }
              if (auth.mode === "password") {
                  // Compatibility: the Control UI currently only persists/sends a "token".
                  // Treat connectAuth.token as the password if connectAuth.password is absent.
                  const password = connectAuth?.password ?? connectAuth?.token;
                  if (!auth.password) {
                      return { ok: false, reason: "password_missing_config" };
                  }
                  if (!password) {
                      return { ok: false, reason: "password_missing" };
                  }
                  if (!safeEqual(password, auth.password)) {
                      return { ok: false, reason: "password_mismatch" };
                  }
                  return { ok: true, method: "password" };
              }
              return { ok: false, reason: "unauthorized" };
          }
