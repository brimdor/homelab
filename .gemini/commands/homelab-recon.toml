description = "Comprehensive analysis, health check, and maintenance report for the entire Homelab"
sync_locations = [
  ".agent/workflows/homelab-recon.md",
  ".opencode/command/homelab-recon.md",
  ".gemini/commands/homelab-recon.toml"
]

prompt = '''

## User Input

```text
$ARGUMENTS
```

You **MUST** consider the user input before proceeding (if not empty).

The text the user typed after the command **is** their priority input - it may specify:
- Specific layers to focus on (Metal, System, Platform, Apps)
- Specific services or namespaces to investigate
- Whether to skip certain phases
- Any special instructions or constraints

---

# Homelab Recon → EXHAUSTIVE Maintenance Spec (Spec-Driven Development)

## Overview
This workflow produces an **EXHAUSTIVE** maintenance issue that `/homelab-action` can execute **safely in small tasks, in the proper order, without context loss**.

It is **Spec-Driven Development (SDD)** adapted to operations:
- **Context**: evidence capture (cluster + repo)
- **Spec**: the maintenance issue (what should change, and why)
- **Plan**: ordering + safety gates + stop conditions
- **Tasks**: top-level issue checkboxes (`- [ ]`) that are atomic
- **Analysis**: self-audit that the issue is complete and actionable
- **Remediation**: fill gaps, rerun analysis
- **Implementation**: delegated to `/homelab-action`
- **Validation**: recon + troubleshoot + recon until GREEN

> [!CAUTION]
> **FOUNDATIONAL RULES APPLY** - See `_foundational-rules.md`.
> The workflow is NOT complete until ALL layers are GREEN (or issues are fully captured in a maintenance issue for action).

> [!IMPORTANT]
> **Do NOT add comments to issues.** Comments are reserved for humans only.
> Always **edit the original issue body** to merge new data into the existing content.

## References
- **Documentation**: https://homelab.eaglepass.io
- **Primary Repo**: https://git.eaglepass.io/ops/homelab
- **Fallback Repo**: https://github.com/brimdor/homelab (auto-synced)

---

## Maintenance Issue Contract (What `/homelab-action` Needs)

The maintenance issue is the **single source of truth**.

To prevent context loss, the issue body MUST:

1. Use **only top-level** executable checkboxes:
   - Every executable step starts with `- [ ]` at the beginning of the line.
   - Do not nest checkboxes for executable work.
2. Make every checkbox **atomic**:
   - One change (or one investigation) + one verification gate.
3. Encode ordering and priority in each checkbox line:
   - `A1 P0 ...`, `B3 P2 ...`, etc.
   - **Priority mapping**: `P0=CRITICAL`, `P1=HIGH`, `P2=MEDIUM`, `P3=LOW`.
4. Include **local context** directly under each checkbox (non-checkbox lines):
   - Goal
   - Commands (exact)
   - Expected (pass criteria)
   - If fails (next diagnostics)
   - Rollback (exact, or “N/A”)
5. Include stable sections (headings), in this order:
   - `## Status`
   - `## Context Pack`
   - `## Proposed Changes (Spec)`
   - `## Execution Plan`
   - `## Action Items (Tasks)`
   - `## Change Log`
   - `## Closure (Filled by homelab-action)`

If any contract requirement is missing, treat it as a **blocking recon failure** and remediate before handoff.

---

## Phase 1: Context Loading (EXHAUSTIVE Evidence Capture)

### 1.1 Access Priority
- **Primary**: use workstation access for Kubernetes and repos
- **Controller fallback**: only when workstation-to-cluster is unavailable
  - SSH: `ssh brimdor@10.0.50.120`
  - Tools container: `cd ~/homelab && make tools`

### 1.2 Validate Access (must succeed)

```bash
kubectl cluster-info
kubectl version --short

ssh -o ConnectTimeout=5 brimdor@10.0.50.120 "echo 'Controller accessible'"

source ~/.config/gitea/.env
curl -s "https://git.eaglepass.io/api/v1/user" -H "Authorization: token $GITEA_TOKEN" | jq -r '.login'
```

### 1.3 Baseline Health Snapshot (capture as evidence)

```bash
# Nodes + capacity
kubectl get nodes -o wide
kubectl top nodes

# Workload health
kubectl get pods -A --sort-by=.metadata.namespace
kubectl get pods -A --no-headers | grep -v "Running\|Completed" || true

# GitOps health
kubectl get applications -n argocd
kubectl get applications -n argocd | grep -v "Synced.*Healthy" || true

# Recent events (last 200)
kubectl get events -A --sort-by=.lastTimestamp | tail -200
```

### 1.4 System/Core Evidence (kube-system, CNI)

```bash
kubectl get pods -n kube-system -o wide
kubectl get pods -n kube-system --no-headers | grep -v "Running\|Completed" || true

# Cilium (if present)
kubectl -n kube-system get ds | grep -i cilium || true
kubectl -n kube-system get pods -l k8s-app=cilium -o wide || true
```

### 1.5 Storage Evidence (Rook/Ceph)

```bash
kubectl -n rook-ceph get pods -o wide
kubectl -n rook-ceph exec deploy/rook-ceph-tools -- ceph health
kubectl -n rook-ceph exec deploy/rook-ceph-tools -- ceph status
kubectl -n rook-ceph exec deploy/rook-ceph-tools -- ceph health detail
kubectl -n rook-ceph exec deploy/rook-ceph-tools -- ceph df
kubectl -n rook-ceph exec deploy/rook-ceph-tools -- ceph osd tree
kubectl -n rook-ceph exec deploy/rook-ceph-tools -- ceph pg stat
```

If Ceph is not `HEALTH_OK`, also capture:
- `ceph crash ls-new` and `ceph crash info <id>` (for each new crash)
- rook-ceph operator logs (recent)

### 1.6 Platform Evidence (Ingress, Certs, Secrets, Observability)

```bash
# Ingress
kubectl get pods -n ingress-nginx -o wide
kubectl get svc -n ingress-nginx
kubectl get ingress -A

# Certificates
kubectl get certificate -A
kubectl get certificaterequest -A | tail -200
kubectl get order -A | tail -200
kubectl get challenge -A | tail -200

# External Secrets
kubectl get externalsecret -A
kubectl get secretstore -A || true
kubectl get clustersecretstore -A || true

# Monitoring namespaces (inventory)
kubectl get pods -n monitoring-system -o wide || true
kubectl get pods -n grafana -o wide || true
```

### 1.7 Apps Evidence (error-focused)

```bash
kubectl get pods -A --no-headers | grep -E "CrashLoopBackOff|Error|ImagePullBackOff|Pending" || true
kubectl get svc -A
```

For each non-running pod, capture:
- `kubectl describe pod -n <ns> <pod>`
- `kubectl logs -n <ns> <pod> --tail=200` (and `--previous` if crashed)

### 1.8 Repo Evidence (Issues + PRs)
Capture:
- Open PRs (Renovate vs user)
- Open issues (excluding `maintenance`)
- Mergeable vs conflicted PRs

Preferred: MCP tools (`gitea_list_repo_pull_requests`, `gitea_list_repo_issues`).
Fallback: Gitea API.

Minimum fields per PR:
- PR number, title, author, created_at (age)
- mergeable state (and blocker if not)
- component affected, version delta
- risk (Low/Medium/High/Critical)

---

## Phase 2: Specification (Define the Maintenance Spec)

The maintenance issue is the spec. It must capture:
- What changes will be made
- Why (findings, security, updates)
- Constraints (ordering, downtime, windows)
- Acceptance criteria (GREEN)

---

## Phase 3: Clarification (Decision Gates)
Only ask humans when required by escalation rules.
Otherwise, encode decisions as tasks (checkboxes) so execution can proceed without missing context.

---

## Phase 4: Planning (Order, Gates, Stop Conditions)

### 4.1 Ordering Rules
- Process `P0 → P1 → P2 → P3`
- Within a priority: `Metal → System → Platform → Apps`
- Databases always last within a priority
- One change at a time; validate GREEN after each

### 4.2 Universal Validation Gate (after every change)

```bash
kubectl get nodes | grep -v "Ready" || true
kubectl get pods -n kube-system | grep -v "Running\|Completed" || true
kubectl get applications -n argocd | grep -v "Synced.*Healthy" || true
kubectl -n rook-ceph exec deploy/rook-ceph-tools -- ceph health
kubectl get pods -A --no-headers | grep -v "Running\|Completed" || true
```

Pass criteria:
- All greps return no output
- `ceph health` returns `HEALTH_OK`

Stop conditions:
- Any non-GREEN result
- Any missing information needed to rollback safely

---

## Phase 5: Task Generation (Report + Maintenance Issue)

### 5.1 Status Report Output (Evidence Archive)
Write a report to `reports/`:
- `reports/status-report-YYYY-MM-DD.md`

The report stores raw evidence; the maintenance issue stores the actionable spec + tasks.

### 5.2 Maintenance Issue Creation/Update
- Find the latest open issue labeled `maintenance`
- If found: edit body (no comments), merge new findings
- If not found: create a new issue titled `[Maintenance] YYYY-MM-DD - Homelab`

Always:
- Add label `maintenance` (ID: 10)
- Assign `gitea_admin`

### 5.3 Maintenance Issue Template (Contract-Complete)

```markdown
# [Maintenance] YYYY-MM-DD - Homelab

## Status
- **Overall**: GREEN / YELLOW / RED
- **Last Updated**: YYYY-MM-DD HH:MM TZ
- **Source Report**: `reports/status-report-YYYY-MM-DD.md`

---

## Context Pack

### Cluster Identity
- K3s version: ...
- Node count: ...
- ArgoCD apps: ...
- Ceph: HEALTH_OK/...

### Current Health Evidence (Snapshot)
- Nodes: ...
- Non-running pods: ...
- ArgoCD non-healthy apps: ...
- Ceph health summary: ...

### Repo Inventory (Actionable)
- Open Renovate PRs: ...
- Open user PRs: ...
- Open non-maintenance issues: ...

---

## Proposed Changes (Spec)

| Item | Type | Layer | Priority | Risk | Summary | Notes |
|------|------|:-----:|:--------:|:----:|---------|-------|

---

## Execution Plan
- Ordering: P0→P3, Metal→Apps, DB last
- Validation gate: run after every change
- Stop conditions: any non-GREEN, any unknown rollback

---

## Action Items (Tasks)

> All executable steps MUST be top-level `- [ ]` checkboxes.
> Each checkbox MUST be atomic.

### Phase A: Preflight
- [ ] A1 P0 Preflight: verify access (kubectl/controller/gitea)
- [ ] A2 P0 Preflight: capture baseline snapshot (nodes/pods/apps/ceph)

### Phase B: Remediate Current Findings
- [ ] B1 P0 System: resolve any Ceph HEALTH_WARN/ERR

### Phase C: Planned Changes (ordered)
- [ ] C1 P2 PR #X: read release notes + list breaking changes
- [ ] C2 P2 PR #X: merge PR
- [ ] C3 P2 PR #X: run validation gate, document outcome

### Phase D: Final Validation
- [ ] D1 P0 Run `/homelab-recon` (final)

---

## Change Log
| Timestamp | Step | Item | Result | Status After |
|-----------|:----:|------|--------|:------------:|

---

## Closure (Filled by homelab-action)
(Use the closure template defined in `homelab-action.md`)
```

---

## Phase 6: Analysis (Self-Audit: Is the Issue Truly EXHAUSTIVE?)

Before handing off to `/homelab-action`, confirm:
- Every non-GREEN finding has a remediation task OR an explicit decision gate
- Every PR has: spec row + merge/close decision + validation task
- Every major/breaking update has: release notes + breaking-change checklist + staged rollout tasks
- Risky steps include backups + rollback
- Tasks are top-level `- [ ]`, atomic, and ordered per Phase 4

If any check fails: return to Phase 1 and gather missing data.

---

## Phase 7: Remediation (Fix Gaps)
Fill gaps, update the maintenance issue body (no comments), then re-run Phase 6.

---

## Phase 8: Implementation (Delegate)
Execute `/homelab-action` to consume the maintenance issue tasks.

---

## Phase 9: Validation & Closure
After `/homelab-action` completes:
- Re-run `/homelab-recon` to confirm all layers GREEN
- If ANY layer is not GREEN: run `/homelab-troubleshoot` to drive back to GREEN
- Re-run `/homelab-recon` again as final proof
- Ensure the maintenance issue is closed with `[RESOLVED]` and includes closure notes

---

## MCP Tool Integration (Preferred)
Use MCP tools for all repo interactions when available:
- `gitea_list_repo_issues` / `gitea_list_repo_pull_requests`
- `gitea_create_issue` / `gitea_edit_issue`
- `gitea_add_issue_labels`

---

## Gitea API Fallback (Emergency Only)

> [!WARNING]
> Use only if MCP tools are unavailable.

### Token Location
```bash
~/.config/gitea/.env        # bash/zsh
~/.config/gitea/gitea.fish  # fish
```

### API Base URL
`https://git.eaglepass.io/api/v1`

---

## Execution Checklist
- [ ] Phase 1: Access verified, evidence captured
- [ ] Phase 5: Status report written to `reports/`
- [ ] Phase 5: Maintenance issue created/updated (no comments)
- [ ] Phase 6: Maintenance issue passes self-audit
- [ ] Phase 9: Final recon + troubleshoot loop yields all GREEN
'''
